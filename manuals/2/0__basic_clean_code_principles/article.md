# Основные принципы чистого кода

Прежде чем говорить о базовых правилах оформления кода программы, давайте определимся с тем, какой код мы будем называть "чистым".

=Чистый код= -- это код, написанный и оформленный таким образом, чтобы его было легко читать, понимать, изменять и поддерживать. Причём не только вам, как автору кода, но и другим программистам.

% **Важно!**
Всегда помните, что в первую очередь код должен быть понятен другим программистам.

Если читая свой код вы постоянно возвращаетесь на предыдущие строки с вопросами навроде "Что лежит в этой переменной?", "А что должна делать эта функция?" или даже "Что я здесь чёрт побери написал?", то скорее всего вы имеете дело с кодом, который нельзя назвать чистым.


Чтобы наглядно продемонстрировать разницу, давайте рассмотрим следующий пример. 

% **Пример**
Написать программу, которая определяет, является ли введённое число простым или составным.
На вход программе можно подавать любое натуральное число, большее `1`.
Если число простое, то программа выводит строку `prime`, иначе -- строку `composite`.

Листинг 1. Пример кода без оформления
```c
#include <stdio.h>
int main(void){
int N;
int tmp =1;
scanf("%d",&N);
for(int i=2;i<N;i++){
if(N%i==0)tmp=0;}
if(tmp>0) printf("prime\n");
else printf("composite\n");
return 0;}
```

Листинг 2. Пример хорошо оформленного кода
```c
#include <stdio.h>

int main(void){

    int number_to_check, 
        is_prime = 1,
        minimal_divisor = 2;
        
    scanf("%d", &number_to_check);

    for (int divisor = minimal_divisor; divisor < number_to_check; divisor++) {
        if (number_to_check % divisor == 0) {
            is_prime = 0;
            break;
        }
    }

    if (is_prime) {
        printf("prime\n");
    } else {
        printf("composite\n");
    }

    return 0;
}
```

Хотя эти два кода работают совершенно одинаково и реализауют один и тот же алгоритм, но ответьте себе, какой из них более понятный и читаемый? В какой из них будет проще вносить изменения и правки? Думаю, что большинство из вас в обоих случаях выберет Листинг 2.

Давайте возьмём код из Листинга 1 и шаг за шагом приведём его в более читаемый и понятный вид, попутно изучая основные принципы написания более чистого кода.

## Стукрутура кода

Основные наши помощники в структурировании кода программы: пустые разделительные строки, отступы и пробелы.

% **Принцип 1:** Используйте пустые строки для разделения кода программы на логические части и блоки.

Какие логические части и блоки можно выделить в Листинге 1? Сперва, конечно, можно разделить подключение заголовочных файлов и определение функции `main`. Но внутри функции main тоже легко выделить три части: объявление и считывание переменных, обработка данных, вывод результата на экран.

Листинг 3. Добавление разделительных пустых строк в Листинг 1.
```c
#include <stdio.h>

int main(void){

int N;
int tmp =1;
scanf("%d",&N);

for(int i=2;i<N;i++){
if(N%i==0)tmp=0;}

if(tmp>0) printf("prime\n");
else printf("composite\n");

return 0;}
```

Выглядит лучше, чем было. Наш код из сплошной портянки текста превратился в отдельные блоки. Появилась хотя бы как-то структура, но этого мало.

% **Принцип 2:** Сдвигайте каждый вложенный блок относительно его "родителя" на несколько позиций вправо.

Например, тело функции `main` стоит сдвинуть на один уровень вправо, относительно основного текста программы. Чаще всего в качестве величины сдвигва (размера отступа) рекомендуют использовать `4` или `8` пробелов. В этом уроке мы используем отступы в `4` пробела.

Листинг 4. Добавление структурных отступов в Листинг 3
```c
#include <stdio.h>

int main(void){

    int N;
    int tmp =1;
    scanf("%d",&N);

    for(int i=2;i<N;i++){
    if(N%i==0) tmp=0;}

    if(tmp>0) printf("prime\n");
    else printf("composite\n");

    return 0;
}
```

Т.е. блоки инструкций в языки Си объединяются в единое целое с помощью фигурных скобок, то фигурная скобка это яркий маркер того, что в этом месте требуется сделать структурный отступ.

Есть три основных стиля расстановки фигурных скобок и отступов:
```c
// первый стиль (K&R)
for (int i = 2; i < N; i++) {
    if (N % i == 0) {
        tmp = 0;
    }
}

// второй стиль (BSD)
for (int i = 2; i < N; i++)
{
    if (N % i == 0)
    {
        tmp = 0;
    }
}

// третий стиль (GNU)
for (int i = 2; i < N; i++)
  {
    if (N % i == 0)
      {
        tmp = 0;
      }
  }
```

% **Принцип 3:** В рамках проекта придерживайтесь единого стиля расстановки фигурных скобок и отсутпов.

Давайте добавим отступы в Листинг 4. Будем использовать стиль K&R.

Листинг 5. Добавление отступов у фигурных скобок
```c
#include <stdio.h>

int main(void) {
    int N;
    int tmp = 1;
    scanf("%d", &N);

    for(int i=2;i<N;i++){
        if(N%i==0){
            tmp=0;
        }
    }

    if(tmp>0){
        printf("prime\n");
    }else{
        printf("composite\n");
    }

    return 0;
}
```

Вообще говоря, здесь можно было бы вообще не использвоать фигурные скобки у `if`-ов и `for`, т.к. во всех случаях внутри них содержится всего лишь одна инструкция. Но чтобы избежать ошибок и упростить себе жизнь в будущем, рекомендую: **всегда добавляйте фигурные скобки в управляющих конструкциях, даже если их можно не использовать**.

Теперь наш код стал гораздо структурированее. Осталось приправить его пробелами, чтобы сделать его ещё более читаемым

% **Принцип 4:** Добавляйте в код пробелы:
%
- после `,`; 
- после `;` внутри заголовка цикла `for`;
- между `)` и `{`;
- с обоих сторон от бинарных операторов.

Листинг 6. Добавление дополнительных пробелов в Листинг 5
```c
#include <stdio.h>

int main(void) {
    int N;
    int tmp = 1;
    scanf("%d", &N);

    for (int i = 2; i < N; i++) {
        if (N % i == 0) {
            tmp = 0;
        }
    }

    if (tmp > 0) {
        printf("prime\n");
    } else {
        printf("composite\n");
    }

    return 0;
}
```

Отдельно каснёмся оформления арифметических выражений. Иногда внутри них опускают пробелы вокруг бинарных операторов, чтобы нагляднее показать структуру выражения и/или приоритет операций. Операторы, имеющие более высокий приоритет, пишут без пробелов, в то время как операторы более низкого приоритета — с пробелами вокруг. Посмотрите на следующий листинг с примерами:

Листинг 7. Примеры оформления арифметических выражений 
b*b + 4*a*c; 				   // сначала умножение, затем сложение
(num_1*num_2) / (num_3*num_4); // сначала вычисляются выражения в числителе и знаменателе
(-b + determinant) / (2*a);	   // добавили пробелы вокруг + для улучшения читаемости


## Имена переменных

% **Принцип 5:** Давайте переменным говорящие, осмысленные имена. Не бойтесь использовать длинные и описательные имена.

Суть совета заклчается в том, чтобы по имени переменной можно было бы понять, что в ней хранится и для чего она используется.

Посмотрите, например, на листинг ниже. 

Листинг 8. Пример плохого стиля именования переменных
```c
#include <stdio.h>

int main() {
    int s=0, d=0, h=0, m=0, 
        hind=24, secinh=3600;

    scanf("%d", &s);

    d = s / (hind * secinh);
    s %= (hind * secinh);

    h = s / secinh;

    printf("%d\n", d);
    printf("%d\n", h);

    return 0;
}
```

Тут без ста грамм не разберёшься. Чтобы понять, что хранится в переменных `d` и `s`, приходится постоянно обращаться к объявлениям `secinh` и `hind`. Здесь будет очень уместна цитата из книги Роберта Мартина «Чистый код»: нет худшей причины для выбора имени `c`, чем та, что имена `a` и `b` уже заняты. 

Вы можете возразить: «`secinh` -- хорошее имя, оно обозначает `sec in hour`, то есть количество секунд в одном часе!». Да, так действительно можно расшифровать. Но очевидное ли это название для человека, который первый раз смотрит на код? Что помешало программисту использвоать имя `seconds_in_hour`? Конечно, название стало длиннее, но зато теперь не возникает дополнительных вопросов. Код становится более читаемым и понятным, что значительно облегчает его поддержку и модификацию.

Приняв решение давать переменным осмысленные имена, мы столкнёмся с проблемой: «Как внутри имени, состоящего из нескольких слов, разделить слова между собой?» 

Существует два основных подхода:

### CamelCase и snake_case

1. =Стиль **CamelCase**= -- каждое новое записывается с заглавной буквы. Название CamelCase связано с тем, что заглавные буквы создают визуальное впечатление “горбов”, как у верблюда. Вот несколько примеров: `DayInMonth`, `NumberTables`, `SecondsPassedFromFirstShot`.
Существует разновидность этого стиля, когда первую букву имени переменной делают строчной, а не заглавной, например: `dayInMonth`.

2. =Стиль **snake_case**= -- слова разделяются нижним подчёркиванием и все буквы обычно строчные. Такое название связано с тем, что нижние подчеркивания визуально напоминают изгибы змеи. Примеры имён переменных, записанных в стиле snake_case использования на тех же именах: `days_in_month`, `number_tables`, `second_passed_from_first_shot`.

Выбор одного из этих стилей –- вопрос личных предпочтений или соглашений, принятых в команде. Главное придерживаться выбранного стиля последовательно во всем проекте. И хотя вы можете придумать свой особый способ именования переменных, всё же рекомендуется придерживаться одного из общепринятых стилей (CamelCase или snake_case), чтобы ваш код был понятен другим разработчикам

Вернёмся к Листингу 6 и внёсём немного смысла в используемые имена перменных.

Листинг 9. Оформленная по всем принципам программа из Листинга 1.
```c
#include <stdio.h>

int main(void){

    int number_to_check, 
        is_prime = 1,
        minimal_divisor = 2;
        
    scanf("%d", &number_to_check);

    for (int divisor = minimal_divisor; divisor < number_to_check; divisor++) {
        if (number_to_check % divisor == 0) {
            is_prime = 0;
            break;
        }
    }

    if (is_prime) {
        printf("prime\n");
    } else {
        printf("composite\n");
    }

    return 0;
}
```

В результате мы получили код, аналогичный Листингу 2, демонстрируя, как применение базовых принципов оформления кода может значительно улучшить его читаемость. 

Заметьте, что в заголоввсе цикла `for` число `2` было заменено на переменную `minimal_divisor`. 

% **Принцип 6:** Избегайте =магических чисел= в коде. 

Вам эти значеиня могут быть понятны, но другие разработчики могут задаться вопросом о том, что это за число. Поэтому лучше если у него будет своё осмысленное и говорящее имя.

Может быть в этом конкретном примере это не очень наглядно, но вот вам другой пример, который буквально сегодня я обнаружил в решениях на Степике.

Листинг 10.
```c
#include <stdio.h>

int main(void)
{
    int N, drop;
    double x, molecule;
    scanf("%d", &N);
    x = 8.317e+24;  
    drop = N * 4990;
    molecule = N * x;
    printf("%d %.4g", drop, molecule);
    return 0;
}
```

Даже видя условие задачи, я не сразу сообразил, что за магические числа `4990` и `8.317e+24`. 


Итак, применив всего несколько простых принципов, мы превратили нечитаемый код в хорошо структурированный и понятный чистый код.

## Комментарии — говорить или молчать?

Комментарии необходимы, чтобы облегчить понимание кода другим програмистам, которые будут его читать и поддерживать. 

Раньше разработчики часто добавляли в начало файла (“шапку”) информацию об авторе, версии кода и историю изменений. Это помогало координировать работу в команде и отслеживать изменения. Однако с появлением =систем управления версиями= (например, Git) необходимость в этих “шапках” отпала.

Тем не менее, комментарии по-прежнему полезны для объяснения сложных алгоритмов, неочевидных решений, ссылок на стандарты или обоснования нестандартного подхода. Однако комментарии, дублирующие очевидный код, не несут никакой пользы и только засоряют его.

Листинг 11. Плохой пример использования комментариев
```c
#include <stdio.h>

int main() {
    // Объявление переменных
    int BatteryCapacityIn_mAh = 0, ConsuptionVoltage = 0, ConsuptionCurrentIn_mA = 0;
    int TimeWorkingBattery_hours = 0, TimeWorkingBattery_minutes = 0;

    printf("Enter Capacity battery, consuption in V and mA: "); // Вывод текста на экран
    scanf("%d %d %d", &BatteryCapacityIn_mAh, &ConsuptionVoltage, &ConsuptionCurrentIn_mA); // Ввод данных

    TimeWorkingBattery_hours = BatteryCapacityIn_mAh / (ConsuptionVoltage*ConsuptionCurrentIn_mA); // Вычисляем время работы в часах. Для этого ёмкость делим на расход
    TimeWorkingBattery_minutes = (BatteryCapacityIn_mAh*60) / (ConsuptionVoltage*ConsuptionCurrentIn_mA); // Вычисляем время работы в минутах домножением на 60

    printf ("\nWorking battery in hours: %d hours\nOR\nWorking battery in minutes: %d minutes\n\n", TimeWorkingBattery_hours, TimeWorkingBattery_minutes); // Вывод информации о времени работы батареи

    return 0;
}
```
Здесь нет ни одного полезного комментария. Эти комментарии лишь описывают очевидный код и не добавляют никакой новой информации, а наоборот, затрудняют чтение. Такие комментарии на зачётах по программированию используют нерадивые студенты, которым программу написал друг или генеративный искусственный интеллект. Им они действительно нужны, т.к. для них комментируемый код зачастую не является очевидным. =)

% **Принцип 7:** Избегайте избыточных и тривиальных комментариев, которые не несут полезной информации.

В целом, старайтесь минимизировать использование комментариев. Если часть кода требует подробного объяснения, возможно, лучше переписать её, чтобы сделать более понятной, чем оставлять сложный код и компенсировать это комментариями.

Чтобы проиллюстрировать разумное использование комментариев, давайте усовершенствуем программу из Листинг 2 (или Листинга 9) следующим образом:

Листинг 12. 
```c
#include <stdio.h>

int main(void){

    int number_to_check, 
        is_prime = 1,
        minimal_divisor = 2;
        
    scanf("%d", &number_to_check);

    /* 
      математическая оптимизация. Перебираем не все делеители, а до sqrt(number_o_check),
      т.к. каждому делителю < sqrt(...) соответствует делитель > sqrt(...).
      Например, для числа 100: делителю 5 < sqrt(100) соответствует делитель 20 > sqrt(100)
    */
    for (int divisor = minimal_divisor; divisor * divisor <= number_to_check; divisor++) {
        if (number_to_check % divisor == 0) {
            is_prime = 0;
            break;
        }
    }

    if (is_prime) {
        printf("prime\n");
    } else {
        printf("composite\n");
    }

    return 0;
}
```

Вот здесь комментарий уместен, т.к. он поясняет используемый математический трюк, который без пояснения может быть совершенно непонятным. 

Резюмирую, запишем основные принципы написания чистого кода:

1. Разделяйте смысловые части и блоки программы пустыми строками.
2. Используйте отступы для вложенных блоков.
3. Используйте пробелы для улучшения читаемости длинных конструкций. 
4. Используйте осмысленные имена переменных.
5. Используйте единый стиль расстановки отступов, фигурных скобок и именования переменных.
6. Избегайте использования "магических" чисел.
7. Избегайте избыточных и тривиальных комментариев.
8. Чтобы код был понятен международному сообществу разработчиков, пишите комментарии на английском языке.