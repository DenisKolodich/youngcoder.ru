# Стандартные математические функции в языке Си

Математические вычисления не ограничиваются лишь арифметическими действиями. Кроме них, можно ещё встретить корни, модули, логарифмы, тригонометрические функции и пр. Научимся же использовать подобные функции в своих программах.

Для использования математических функций нужно подключить заголовочный файл `math.h`.

Некоторые математические функции:

- `fabs(x)` -- модуль числа `x`
- `sqrt(x)` -- квадратный корень из числа `x`
- `sin(x)` -- синус числа `x` (`х` в радианах)
- `cos(x)` -- косинус числа `x` (`х` в радианах)
- `pow(x, y)` -- вычисление `x`<sup>`y`</sup>
- `exp(x)` -- вычисление `e`<sup>`x`</sup>
- `log(x)` -- натуральный логарифм числа `x`
- `log10(x)` -- десятичный логарифм числа `x`

Два важных момента.

- Все указанные функции возвращают значение типа `double`.

- В качестве аргументов эти функции принимают вещественные числа типа `double`, но можно передать и числа других типов (например, `int`, `float`). При этом произойдёт =неявное преобразование (приведение) типа=. Компилятор из целого числа, например `3`, сделает число `3.0`, которое будет иметь тип `double`.

### Примеры использования математический функций:

**Задача 1:** Даны длины катетов прямоугольного треугольника. Вычислить длину гипотенузы. 

Простая задачка на знание теоремы Пифагора.

Листинг 1.
```c
#include <stdio.h>
#include <math.h> // подключаем math.h

int main (void)
{
        int a, b, c2;

        scanf("%d", &a);
        scanf("%d", &b);

        c2 = a*a + b*b;
        printf("c = %.2f\n", sqrt(c2)); // так как sqrt возвращает double,
                                        // то используем спецификатор %f
        return 0;
}
```

Из интересного в этой программе лишь неявное преобразование типа, которое происходит, когда мы вызываем функцию `sqrt`. Допустим, мы запустили программу и ввели `3` и `4`. В переменную `c2` (типа `int`) будет записано значение `3*3 + 4*4 = 25`. Когда мы пишем вызов функции `sqrt(c2)`, то вместо `c2`, как мы уже знаем, подставляется значение, которое в ней хранится, т.е. `25`, получаем: `sqrt(25)`. Но как нам уже известно, функция `sqrt` ждёт от нас значения типа `double`, а мы ей передали значение типа `int`. Поэтому компилятор сначала выполнит неявное приведение типа: преобразует целое значение `3` в вещественное значение `3.0`.   


**Задача 2:** Вычислить синус угла, введённого с клавиатуры. Угол вводится в градусах.

Листинг 2.
```c
#include <stdio.h>
#include <math.h> // подключаем math.h

int main (void)
{
        double alpha, sin_a, pi = 3.1415926;

        scanf("%lf", &alpha);
        
        alpha =  alpha * pi / 180;
        sin_a = sin(alpha);

        printf("%.2f\n", sin_a);

        return 0;
}
```

Тригонометрические функции математической библиотеки языка Си работают с радианной мерой угла (угол, заданный в радианах). Людям же привычнее работать с градусной мерой угла (углом, заданным в градусах). Поэтому в данной программе мы предварительно [переводим значение из градусов в радианы](https://stepik.org/lesson/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D0%B2-%D0%A1%D0%B8-40857/step/9). 
Если этого не сделать, результат получится неправильным. Проверьте это самостоятельно.

## Неявное преобразование типов
При явном преобразовании типа мы в скобках перед значением указывали тип, к которому нужно привести данное значение. В неявном преобразовании этого делать не нужно. Компилятор автоматически подберёт необходимый тип.

%
Неявное преобразование типов осуществляется в следующих случаях:
1. перед передачей аргументов в функцию
2. выполнение арифметических операций с разными типами аргументов
3. перед выполнением присваивания

Неявное преобразование типа при передаче аргумента в функцию мы обсудили выше (вызов функции `sqrt` в Листинге 1). 

Пример неявного преобразования типа из пункта `2` мы встречали в прошлой заметке, когда разбирались с тем, как получить правильный результат деления `7` на `2`. Давайте посмотрим на Листинг 3 из прошлого шага:

Листинг 3.
```c
#include <stdio.h>

int main(void)
{
        int a = 7, b = 2;
        float res;

        res = (float) a / b;
        printf("%d / %d = %f\n", a, b, res);

        return 0;
}
```

Разберём поподробнее, как будет обрабатываться строка `res = (float) a / b;`.

Сначала подставим значения переменных `a` и `b`: `res = (float) 7 / 2;` 
Далее произведём явное приведение типа для значения `7`: `res = 7.0 / 2;`

Т.к. процессоры умеют выполнять арифметические операции только с операндами одного и того же типа, то компилятору нужно произвести неявное приведение типа для значения `2`. Поэтому на этом этапе значение `2` преобразуется в значение `2.0`. Получаем: `res = 7.0 / 2.0;`

Получается, что в прошлом уроке мы изучили небольшой программистский "хак", связанный с преобразованием типов. Для правильного выполнения деления мы должны были бы сами явно привести оба числа к типу `float`, но мы схитрили и явно привели к типу `float` только одно число, а второе число преобразовал уже компилятор неявно. =)


### Правила неявного преобразования типов

% **Важно!**
* если выполняются арифметические операции с разными типами аргументов, Оба аргумента приводятся к большему типу. Старшинство типов: `int` < `float` < `double`
* при вызове функций, переданные аргументы преобразуются к типам данных, которые ожидает функция.
* при присваивании. Значение справа от оператора присваивания приводится к типу переменной слева от оператора присваивания. 

Снова обращаю ваше внимание на то, что если при неявном преобразовании типов может произойти =потеря точности=. 

**Примеры:**

- `int + float` будет автоматически преобразовано к `float + float`
- `float / int` будет автоматически преобразовано к `float / float`
- `double * float` будет преобразовано к `double * double`
- `int = double` `double` будет преобразовано к `int` с потерей дробной части
- `float = int` `int` будет преобразовано к `float`

Учитывая разобранные правила, посмотрим на Листинг 4 из прошлого урока.

Листинг 4.
```c
int a = 7, b;
float g = 9.81, v;

b = (int) g; // приводим значение 9.81 к типу int, получим 9
v = (float) a; // приводим значение 7 к типу float, получим 7.0
```

В этом кусочке кода мы явно преобразовали тип значений справа от оператора присваивания. Но теперь, зная правила неявного преобразования типов, мы понимаем, что этого можно было бы и не делать, т.к. компилятор провёл бы эту процедуру самостоятельно. Т.е. можно было бы просто записать:
```c
b = g; \\ значение 9.81 будет неявно преобразовано к типу int, получим 9
v = a; \\ значение 7 будет неявно преобразовано к типу float, получим 7.0
```